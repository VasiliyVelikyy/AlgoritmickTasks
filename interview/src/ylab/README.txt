
Для каждой задачи реализовать отдельный класс с методом main, в котором
демонстрируется работа решения.
Пример для Sequences.
Интерфейс называется Sequences
Реализация - SequencesImpl
Демонстрация - SequencesTest. В данном классе есть метод main, в котором создается
экземпляр объекта и вызываются методы


Комментарии к задачам урока 2

SequenceGenerator
В данной задаче проверяется способность увидеть,
закономерности, понять формулу. реализовать в коде. Вопросы
переполнения и граничных условий - это вопросы важные, но в
данном случае задача не об этом. Для определенности - можно
положить, что N никогда не будет больше 10 (ну или 20, в
зависимости от используемых типов данных)

ComplexNumbers
Внимание стоить обратить на метод получения модуля.
Данный метод не обязан создавать новый объект типа
ComplexNumber, потому как это некая характеристика числа,
вполне допустимо реализовать метод, возвращающий
результат типа double. Сложение, вычитание и умножение - это
арифметические операции, в результате которых появляется
новое число; в этих методах создавать новый объект можно и
нужно.

SnilsValidator
Необходимо реализовать именно тот алгоритм валидации,
который приведен в тексте задания. Особое внимание - строка,
поданная на вход в метод валидации может быть,
произвольной. Но при этом метод должен возвращать true
тогда и только тогда, когда СНИЛС считается валидным по
алгоритму выше

StatsAccumulator
Есть некоторая неопределенность, что можно считать,
максимальным и минимальным элементом переданной
последовательности в том случае, когда ни один элемент не
был добавлен методом add. Допустимым считается 0 или
Integer.MIN/МАХ_VALUE. Если элементов не было добавлено, то
количество 0, среднее арифметическое тоже 0.
В общем случае можете полагать, что методы, которые должны
быть реализованы, будут вызываться после добавления как
минимум 1 элемента.
Допустимо также использовать классы обертки для методов.
получения минимального/максимального элемента,
количества и среднего арифметического