package testtask;

import java.util.Scanner;

/*Индекс сырков
Нет ответа
27 апр. 23:42
Ограничение времени	5 секунд
Ограничение памяти	256 Мб
Ввод	стандартный ввод
Вывод	стандартный вывод
В стране Y YY остро стоит проблема с глазированными сырками — населению катастрофически их не хватает, а производители так и норовят завысить цену. Поэтому, чтобы избежать бунтов, правительство решило ввести льготы для производителей и установить фиксированные цены для покупателей.

Центральный банк публикует план цен на глазированные сырки на n nn дней, и все в стране его соблюдают.

Студент Дмитрий решил, что это отличный способ заработать. Он взял план и решил посчитать, сколько возможностей для увеличения капитала у него есть.

Пусть p ( d ) p(d)p(d) — это функция, которая определяет цену p pp сырка в зависимости от дня d dd. Возможность для заработка возникает в ситуации, когда для дней x xx и y yy таких, что x < y x < yx<y выполняется условие p ( x ) < p ( y ) p(x) < p(y)p(x)<p(y). Это означает, что Дмитрий может купить сырки в день x по более низкой цене и продать их в день y по более высокой цене, заработав на разнице.

Формат ввода
В первой строке содержится натуральное число n nn — количество дней, на которое составлен план цен на сырки.

В следующих n nn строках содержится по одному натуральному числу p i p_ip
i
​
  — цена сырка в день i ii.

1 ≤ n ≤ 4000000 1 \leq n \leq 4 000 0001≤n≤4000000, 1 ≤ p i ≤ 200 1 \leq p_i \leq 2001≤p
i
​
 ≤200

Формат вывода
Выведите одно число — количество возможностей для заработка.

Пример 1
Ввод	Вывод
1
40
0
Пример 2
Ввод	Вывод
3
40
50
60
3
Пример 3
Ввод	Вывод
3
80
70
60
0*/
public class IndexOfCheesecakes {
    public static void main(String[] args) {
        IndexOfCheesecakes solution = new IndexOfCheesecakes();
        int[] mass = solution.enterVal();
        int answer = solution.evaluate(mass);
    }

    private int evaluate(int[] mass) {

        int initialPrice=mass[0];
        int count = 0;
        for (int i = 1; i < mass.length; i++) {
            if(mass[i]<initialPrice){
                initialPrice=mass[i];
            }
            else {
                count++;
            }
        }

        return count+1;
    }

    private int[] enterVal() {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = scanner.nextInt();
        }

        scanner.close();
        return a;
    }
}
